{
  "hash": "fe7b3010447132d0b3eaa3b6748aca1a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle:  Palmer penguins and discrete predictors\ndescription: |\n  fitting a model with discrete predictors.\nexecute:\n  freeze: true\nformat:\n  html:\n    code-tools: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n\nIn this section we're going to look at models with one discrete predictor. \nYou may have encountered this kind of model with discrete predictors. \n\n## Load packages and data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\nlibrary(tidyverse)\n# library(cmdstanr)\nsuppressPackageStartupMessages(library(rstan))\nrstan_options(\"auto_write\" = TRUE)\noptions(mc.cores = parallel::detectCores())\nlibrary(tidybayes)\n```\n:::\n\n\n\n## Data exploration\n\nLet's start by taking a look at the Palmer Penguin dataset by looking at the distribution of observations of bill size.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(palmerpenguins)\npenguins |> \n  ggplot(aes(x=bill_depth_mm)) + \n  geom_histogram(binwidth = .5)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Histogram of bill depth for all the penguins in the Palmer Penguin dataset.](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\nThere's quite a lot of variation in these measurements, with a suggestion of perhaps more than one peak in this distribution.\n\n## A simple model\n\n$$\n\\begin{align}\n\\text{Bill depth} &\\sim \\text{Normal}(\\mu, \\sigma)\\\\\n\\mu &\\sim \\text{Normal}(17.5, 2) \\\\\n\\sigma &\\sim \\text{Exponential}(1) \\\\\n\\end{align}\n$$\n\nlet's express the same model in Stan:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormal_dist <- stan_model(\n  \"topics/discrete_predictor/normal_dist.stan\")\nnormal_dist\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\nS4 class stanmodel 'anon_model' coded as follows:\ndata {\n  int N;\n  vector[N] measurements;\n}\nparameters {\n  real mu;\n  real<lower=0> sigma;\n}\nmodel {\n  // priors\n  mu ~ normal(17,2);\n  sigma ~ exponential(1);\n  // likelihood\n  measurements ~ normal(mu, sigma);\n} \n```\n\n\n:::\n:::\n\n\n\nThe model section looks very much like the mathematics shown above. \nI want you to notice especially how the bottom chunk has three lines, each describing a probability distribution. \nModels are devices for putting together the probability of all the quantities we are looking for. \nAgain, a Bayesian separates the world into unmeasured or measured quantities -- and above we state which are observed (the data block) and which are unobserved (the parameters block).\n\nBefore we fit this model we need to get the data ready. \nWe'll drop NA values^[just for this toy example!], and set up the data in a list.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first we drop all NA values\npenguins_nobillNA <- penguins |> \n  #drop NA values\n  filter(!is.na(bill_depth_mm))\n\n## then we assemble the data as a list.\n## I'm using the base function with()\n##  it lets me use the variable name directly \n## without writing penguins_nobillNA$bill_depth_mm\n\nlist_bill_dep <- with(penguins_nobillNA,\n     list(N = length(bill_depth_mm),\n          measurements = bill_depth_mm))\n     \n## sample 4 chains, suppress counting iterations\nnormal_bill_dep_samp <- sampling(normal_dist,\n                               data = list_bill_dep, \n                               refresh = 0)\n\n## summarize the samples for each parameter into a nice table\nnormal_bill_dep_samp |> \n  posterior::summarise_draws() |> \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n|variable |        mean|      median|        sd|       mad|          q5|         q95|     rhat| ess_bulk| ess_tail|\n|:--------|-----------:|-----------:|---------:|---------:|-----------:|-----------:|--------:|--------:|--------:|\n|mu       |   17.148944|   17.149876| 0.1053078| 0.1043844|   16.974258|   17.321932| 1.000619| 3296.251| 2109.761|\n|sigma    |    1.976812|    1.975143| 0.0755066| 0.0752288|    1.856026|    2.106336| 1.001637| 3185.266| 2204.132|\n|lp__     | -405.498917| -405.193215| 0.9854578| 0.7222621| -407.463281| -404.562381| 1.001645| 1701.458| 2529.016|\n\n\n:::\n:::\n\n\n\n\n## Plotting parameters. \n\nWe don't have one value for each of our unknown numbers: we have thousands. \nWe need to get a sense of what these possible values mean scientifically. \nAn excellent way to do this is by making as many pictures as possible. \nWe will start with making plots of specific parameters. \n\nWe can look at the distributions easily using the `bayesplot` package.\n\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nbayesplot::mcmc_hist(normal_bill_dep_samp, pars = \"mu\")  + \n  coord_cartesian(xlim = c(10, 25))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\nbayesplot::mcmc_hist(normal_bill_dep_samp, pars = \"sigma\") + \n  coord_cartesian(xlim = c(0, 7))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n\n\n\nNotice that the distributions do not have the same shape as the prior-- this is particularly true for $\\sigma$. \n\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\ntibble(param = c(\"mu\"), \n       values= rnorm(200, 17.5, 2)) |> \n  ggplot(aes(x = values)) + \n  geom_histogram() + \n  coord_cartesian(xlim = c(10,25))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n\n```{.r .cell-code}\ntibble(param = c(\"sigma\"), \n       values= rexp(200,1)) |> \n  ggplot(aes(x = values)) + \n  geom_histogram() + \n  coord_cartesian(xlim = c(0,7))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-2.png){width=672}\n:::\n:::\n\n\n\n\nThis shows an important point: the prior distribution does not determine what the posterior looks like. \n\n## Posterior predictions: the easy way to check your model\n\nIn my experience, ecologists (rightly!) care a great deal about model diagnostics. \nAnd with good reason: you need to know how much to trust a model before using it to make a scientific claim. \nBayes offers a straightforward way to show how well a model is doing: plot model predictions, and compare them to the observed data. \nThis involves using the model as a data generating machine, which we'll look at next.\n\n### Posterior prediction in R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# just get some draws\ndraws <- rstan::extract(normal_bill_dep_samp, pars = c(\"mu\", \"sigma\"))\ndraws_matrix <- posterior::as_draws_matrix(draws)\n\n## set up a matrix. for every posterior sample, \n## (that is, for a value of mu and a value of sigma) \n## draw a whole fake dataset from a normal distribution with that mean and sd. \nnsamples <- 50\nyrep <- matrix(0, ncol = list_bill_dep$N, nrow = nsamples)\n\n# pick some random rows\nset.seed(1234)\nchosen_samples <- sample(1:nrow(draws_matrix), replace = FALSE, size = nsamples)\nsubset_draws <- draws_matrix[chosen_samples,]\n\nfor (r in 1:nsamples){\n yrep[r,] <- rnorm(n = list_bill_dep$N, \n                   mean = subset_draws[r, \"mu\"], \n                   sd = subset_draws[r, \"sigma\"])\n}\n\nbayesplot::ppc_dens_overlay(y = list_bill_dep$measurements,\n                            yrep = yrep)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\n### Posterior predictions in Stan\n\n::: {.callout-tip}\n### EXERCISE\nIn the code above I show how to simulate the posterior predictive distribution using the posterior draws for $\\mu$ and $\\sigma$. \nHowever, if you want, you can do the same process in Stan.   \n\n1. Extend the Stan code above to simulate new observations using the `generated quantities` block. (Tip: look back at the [Simulation exercise](topics/01_simulation)).  \n2. plot them using bayesplot, as above.\n:::\n\n::: {.callout-note collapse=\"true\"}\n### SOLUTION\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormal_dist_rng <- stan_model(file = \"topics/discrete_predictor/normal_dist_rng.stan\")\n\nnormal_dist_rng\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\nS4 class stanmodel 'anon_model' coded as follows:\ndata {\n  int N;\n  vector[N] measurements;\n}\nparameters {\n  real mu;\n  real<lower=0> sigma;\n}\nmodel {\n  measurements ~ normal(mu, sigma);\n  mu ~ normal(17,2);\n  sigma ~ exponential(1);\n}\ngenerated quantities{\n  vector[N] yrep;\n  for (i in 1:N){\n    yrep[i] = normal_rng(mu, sigma);\n  }\n} \n```\n\n\n:::\n:::\n\n\n\nHere we have a handy random number generator _inside_ Stan.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamp_bill_dep_rng <- sampling(normal_dist_rng,\n  data = list_bill_dep,\n  refresh = 0)\n\nsamp_bill_dep_rng_draws <- rstan::extract(samp_bill_dep_rng, pars = \"yrep\")\nsamp_bill_dep_rng_draws_matrix <- posterior::as_draws_matrix(samp_bill_dep_rng_draws$yrep)\n\nbayesplot::ppc_dens_overlay(y = list_bill_dep$measurements,\n                            yrep = head(samp_bill_dep_rng_draws_matrix, 50))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\nThe code is much shorter, because there is less to do in R. \n\n:::\n\nBoth of these gives the same outcome: the posterior predictive distribution. \nThis gives us a straightfoward way to test our model's performance: \n\n1. we use the model to generate fake observations. \n2. plot these on top of the real data\n3. if the data is a really poor match, we know our model has a distorted view of the world.\n\n## Different groups are different\n\nlet's add in differences among species\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  ggplot(aes(x = bill_depth_mm, fill = species))+ \n  geom_histogram(binwidth = .5) + \n  scale_fill_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_bin()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\nNow we can see that the distribution is in fact three different shapes, all placed together. \n\n:::{.callout-warning}\nSometimes scientists will plot histograms of data at the beginning of a research project, and use the histogram to decide if their data are \"normally distributed\" or not. This is not helpful! Instead, decide on a model first, and ask yourself what kind of data you expect.\n:::\n\n## Stan code for species differences\n\n\n$$\n\\begin{align}\n\\text{Bill depth}_{i} &\\sim \\text{Normal}(\\mu_{\\text{species}[i]}, \\sigma) \\\\\n\\mu_{\\text{species}} &\\sim \\text{Normal}(17, 2) \\\\\n\\sigma &\\sim \\text{Exponential}(2) \\\\\n\\end{align}\n$$\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormal_dist_rng_spp_forloop <- stan_model(file = \"topics/discrete_predictor/normal_dist_rng_spp_forloop.stan\")\n\nnormal_dist_rng_spp_forloop\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\nS4 class stanmodel 'anon_model' coded as follows:\ndata {\n  int N;\n  vector[N] measurements;\n  array[N] int<lower=1,upper=3> spp_id;\n}\nparameters {\n  vector[3] mu;\n  real<lower=0> sigma;\n}\nmodel {\n  for (i in 1:N){\n    measurements[i] ~ normal(mu[spp_id[i]], sigma);\n  }\n  mu ~ normal(17,2);\n  sigma ~ exponential(1);\n}\ngenerated quantities{\n  vector[N] yrep;\n  for (i in 1:N){\n    yrep[i] = normal_rng(mu[spp_id[i]], sigma);\n  }\n} \n```\n\n\n:::\n:::\n\n\n\nThere's a few differences to notice here:\n\n* in the `data` block: We have a new input! A declaration of the array of integers at the top, saying if this is \"species 1\", \"species 2\", or \"species 3\"\n* `mu` is a vector now. why?\n* notice the for-loop. \n\n## Quick detour : vector indexing\n\nA **very** useful technique, in both R and Stan, is transforming a vector with _indexing_. \nVector indexing requires two vectors: the first contains values we want to select or replicate, the second contains integers giving the positions of the elements we want. For example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsome_values <- c(\"taco\", \"cat\", \"goat\", \"cheeze\", \"pizza\")\npositions <- c(1,1,2,2,3,1,1,5)\n\nsome_values[positions]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"taco\"  \"taco\"  \"cat\"   \"cat\"   \"goat\"  \"taco\"  \"taco\"  \"pizza\"\n```\n\n\n:::\n:::\n\n\n\nThis works for number values as well, and is very useful when you want to do simulations! let's simulate three groups with different averages.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(525600)\nsome_means <- c(12, 17, 19)\nsome_labels <- c(\"taco\", \"cat\", \"goat\")\n\ndf_of_means <- data.frame(index = rep(1:3, each = 42)) |> \n  mutate(the_mean = some_means[index],\n         labels = some_labels[index],\n         obs = rnorm(n = length(the_mean),\n                     mean = the_mean,\n                     sd = 1))\n\ndf_of_means |> \n  ggplot(aes(x = obs, fill = labels)) + \n  geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n## Vector indexing in Stan\n\nWe can use this very same technique in Stan: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormal_dist_rng_spp <- stan_model(file = \"topics/discrete_predictor/normal_dist_rng_spp.stan\")\n\nnormal_dist_rng_spp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\nS4 class stanmodel 'anon_model' coded as follows:\ndata {\n  int N;\n  vector[N] measurements;\n  array[N] int<lower=1,upper=3> spp_id;\n}\nparameters {\n  vector[3] mu;\n  real<lower=0> sigma;\n}\nmodel {\n  measurements ~ normal(mu[spp_id], sigma);\n  mu ~ normal(17,2);\n  sigma ~ exponential(1);\n}\ngenerated quantities{\n  vector[N] yrep;\n  for (i in 1:N){\n    yrep[i] = normal_rng(mu[spp_id[i]], sigma);\n  }\n} \n```\n\n\n:::\n:::\n\n\n\nThe only difference to the previous model is in the line with the for-loop, which is now replaced with a vectorized expression. This is faster to write and will run faster in Stan. However it's not possible in every case.\n\n### Sampling the species model\n\n:::{.callout-tip}\n### EXERCISE\nFit one (or both) of the species-specific models above. \n1. What changes do you need to make to the input data? Remember we've added a new input: a vector of numbers 1, 2, or 3 that tells us if we are working with the first, second, or third species. There are many ways to do this (e.g. try using `as.numeric` after `as.factor`)  \n2. Visualize the posterior with `bayesplot`. Does it look better than the model without species? How can you tell?\n:::\n\n::: {.callout-note collapse=\"true\"}\n### SOLUTION\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_bill_dep_spp <- with(penguins_nobillNA,\n     list(\n       N = length(bill_depth_mm),\n       measurements = bill_depth_mm,\n       spp_id = as.numeric(as.factor(species))\n     )\n)\n     \nnormal_dist_rng_spp_samp <- sampling(normal_dist_rng_spp,\n  data = list_bill_dep_spp, \n  refresh = 0)\n```\n:::\n\n\n\nLet's take a look at this in Shinystan\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinystan::launch_shinystan(samp_normal_dist_rng_spp)\n```\n:::\n\n\n\n\nand we can repeat the posterior checking from before:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract and convert draws\nspp_yrep_draws <- extract(normal_dist_rng_spp_samp, pars = c(\"yrep\"))\n\n# Posterior predictive check\nbayesplot::ppc_dens_overlay(y = list_bill_dep$measurements,\n                            yrep = head(spp_yrep_draws$yrep, 50))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n\nThe predicted distribution is now much more like the real data!\n\n:::\n\n### Visualizing species -- using `tidybayes`\n\nWe can also make figures for each individual species. \nHere we will move away from using `bayesplot` and try to visualize our posterior using the handy functions in the [`tidybayes` package](https://mjskay.github.io/tidybayes/).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidybayes)\n\nnormal_dist_post_samp <- tidybayes::gather_draws(normal_dist_rng_spp_samp,\n                        yrep[row_id], \n                        ndraws = 50)\n\nnormal_dist_post_samp |> \n  mutate(species = penguins_nobillNA$species[row_id]) |> \n  ggplot(aes(x = .value, colour = species)) + \n  geom_density(aes(group = .iteration), alpha = .1) + \n  facet_wrap(~species) + \n  geom_density(aes(x = bill_depth_mm),\n               data = penguins_nobillNA,\n               colour = \"black\") + \n  scale_colour_brewer(palette = \"Dark2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n\n### Exercises\n\n\n#### Level 1\n* repeat this experience for another variable in the dataset. Does the same code work on bill length? What about body size? What would you change about the model (if anything)\n* use bayesplot to examine the fit of body size to these data. \n\n#### Level 2\n* generate some random groups of your own, with known means. How well does the model fit these data\n* The present model is fixed for exactly 3 groups. how would you change it for any number of groups?\n\n#### Level 3\n* the function `tidybayes::compose_data` is a convenient way to set up your data for passing it into R. Try out this function. What does it produce for our dataset? How do you need to modify our Stan program so that it works for the output of `tidybayes::compose_data`?\n* As you can see, the model assumes the same sigma for all species. what if you relax this? \n\n### Optional! \nTry this on your own data! ",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}