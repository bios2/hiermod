{
  "hash": "248f95d4ce28add54ff260d1e800e8e9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introduction to Stan and simulation\"\ndescription: |\n  Repeating yesterday's exercise, with the programming language Stan.\nexecute:\n  freeze: true\ncomments:\n  hypothesis: false\nformat:\n  html:\n    code-tools: true\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(rstan)\nrstan_options(\"auto_write\" = TRUE)\n```\n:::\n\n\n\n:::{.callout-tip}\n## Goals of this lesson\n1. Introduce the idea of a generative model\n1. Using generated data to validate a model\n1. Stan model syntax\n1. Outline of a Bayesian workflow\n:::\n\n\n### The process\n\nTo practice our first models in Stan, we'll being with an imaginary example based on [yesterday's activity](topics/00_distributions). We'll imagine we're conducting a particularly pleasant study: counting birds! \n\n**Question** How many birds will each person in the class find? For the purposes of this example, let's say there are 22 people.\n\n1. We're going to count birds, so we'll have count data: a number that is either 0 or some positive, round number\n2. We'll make a simplifying assumption: everybody has the same chance of seeing a bird (i.e. no differences in skill or equipment), and everyone in the class is an independent observer (i.e. nobody is working in pairs, etc.) \n3. Everyone in the class makes only one count, so we have 22 numbers.\n\nWe're Bayesian, so we need to write a probability distribution for all the possible values.\n\n$$\n\\begin{align}\n\\text{Number of Birds}_{\\text{seen by person i}} &\\sim \\text{Poisson}(\\lambda) \\\\\n\\lambda &\\sim \\text{Uniform}(0, 60)\n\\end{align}\n$$\n\nA quick note about notation for models like these:\n\n* We use a subscript $i$ to indicate the \"label\" for each observation in our dataset. You can think of this as the row number of the data spreadsheet, and imagine sliding your finger down the column of measurements, modelling each value in turn.\n* Usually we'll use more general language, such as $y_i$. But for this simple example I wanted to make things as explicit as possible. \n* Notice the symbol $\\sim$. This is read as \"distributed as\", and indicates the probability distribution from which the values might come.  When the values we're talking about are data that we can observe (in this case, counts of birds), we call the distribution the likelihood. When the value is something we can't observe (in this case, the average count $\\lambda$) we call the distribution the prior. \n\n<aside>Remember that measuring uncertainty with probability is what makes thinking Bayesian. That means we need a probability distribution for everything we can't observe (like an average) or haven't seen yet (like observations)</aside>\n\n::: {.callout-warning}\nWe'll be talking about better ways to model count data in a later exercise! For now, I'm using the Uniform distribution for simplicity. It's not usually a very good choice! \n:::\n\n### Simulation in R\n\nBefore starting work on real data, we are going to begin by learning how to generate data by simulation.\nThere are at least three reasons why this is a good idea:\n\n1.  **Understand your priors.**. For most interesting models in ecology, you will not be able to pick good numbers for your prior parameters just by thinking hard. Should the prior on annual tree growth be $\\text{Normal}(2, 1)$ ? Or should the standard deviation be bigger? Smaller? As we'll see, simulation will demystify the process. \n1. **Validate your model.** Bayesian models are great because they can create datasets by simulation. This suggests a very minimum requirement we might have for a statistical model: use known parameters and a model to generate data, then fit that same model to the very data it generated, and see if we get back something close to those known parameter values.\n1. **Test your understanding.** Perhaps most importantly, simulation helps you to test your own intuition.  If you can simulate data from your model, then you really understand it!\nIf you can't, then you don't know quite how it works yet. It's rare^[in Andrew's experience anyway!] that a biologist will fail to learn something by simulating a dataset.\n\n## Simple exercise in simulation\n\nLet's imagine we are taking a walk as a group today at this beautiful field site. What is the number of birds (total abundance of ALL species) each of us is going to see on our hike?\n\n### Some questions to ask about simulated data\n\n1. What kind of observations are you going to make? Do they have a minimum or maximum value?\nAre they integers, or are they decimal numbers, or something else?\n1. Where do the numbers come from? This could be anything, from simple linear approximations (i.e. the models we're looking at in this course) to ODEs, mathematical models, GAMs, etc. \n1. How many observations will we be making?\n\nOne of the most useful traits of Bayesian models is that they are _generative_: they can be used to make a simulated dataset. \nWe'll do that now for our bird example.\n\nlet's simulate from a Poisson distribution:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(525600)\nn_people <- 21\navg_birds_per_person <- runif(1, min = 0, max = 30)\nbird_count <- rpois(n_people, lambda = avg_birds_per_person)\n```\n:::\n\n\n\nSome things to note in the code above: \n\nEvery statistical distribution that is in R (which is a lot! almost all! ) has four different functions. \nIf the distribution is called `dist`, then they are:\n\n* `rdist` = draw random numbers from `dist` \n* `qdist` = the quantile function -- what value gives a certain proportion of the distribution?\n* `pdist` = the probability density function -- what proportion of the distribution is below a certain value?\n* `ddist` the density function = draws the \"shape\" of a distribution. How probable are specific values?\n\nThe other thing to note is that there are TWO simulation steps here: **first**, simulating a value of the average ($\\lambda$) and **second**, simulating observations. \nIn our model, the Uniform distribution was referred to as the _prior_, and the Poisson distribution was referred to as a _likelihood_, but here you can see that they are very nearly the same thing: just statements about what distribution of values might be most consistent with the data.\n\n#### Plotting the result\n\nLet's take a look at our simulated values:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bird_count, col = \"lightblue\", xlim = c(0, 50))\n```\n\n::: {.cell-output-display}\n![Histogram of simulated counts of birds](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\nThis is pretty great, and represents one possible realization of sampling. \nHowever, one sample isn't enough to tell us about what our $\\text{Uniform}(0, 60)$ prior really means. \n\n:::{.callout-tip}\n### EXERCISE\nTry to make many different simulations (say, 12 simulations). This represents 12 different repeats of the whole process: draw a value from the uniform prior, THEN draw a value from the poisson. Visualize them any way you want! (the worked example below uses `ggplot2`)\n:::\n\n::: {.callout-note collapse=\"true\"}\n### SOLUTION\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(525600)\n\nsimulate_some_birds <- function() {\n  lambda <- runif(1, min = 0, max = 60)\n  data.frame(obs = rpois(23, lambda = lambda))\n}\n\nrep_list <- replicate(12, simulate_some_birds())\n\ntibble::tibble(simulation = 1:12,\n               obs = rep_list) |> \n  unnest(cols = \"obs\") |> \n  ggplot(aes(x = obs)) + \n  geom_histogram(bins = 28) + \n  facet_wrap(~simulation) + \n  theme_bw() + \n  labs(x = \"Number of birds observed per person\")\n```\n\n::: {.cell-output-display}\n![Twelve different simulations of a possible bird dataset. Do all of these seem plausible?](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n:::\n\nThis figure shows different simulations of what, according to our prior, might be reasonable datasets for us to study. Do any of them seem implausible to you? If so, try changing the prior. The goal is to make fake datasets that _seem_ plausible, but which still include the possibility of some surprising observations. \n\nWhen you have a prior that generates observations that cover a range of scientifically reasonable values, then you are ready to move on to fitting real data.\n\nHowever before we actually do that, let's do the whole thing again: this time in Stan.\n\n## Simulating data in Stan\n\nLet's look back at the equation:\n\n$$\n\\begin{align}\n\\text{Number of Birds}_{\\text{seen by person i}} &\\sim \\text{Poisson}(\\lambda) \\\\\n\\lambda &\\sim \\text{Uniform}(0, 60)\n\\end{align}\n$$\n\nAnd then translate it into Stan:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoisson_simulation <- rstan::stan_model(\n  file = \"topics/01_simulation/poisson_simulation.stan\", \n  model_name = \"poisson_simulation\",\n  save_dso = TRUE\n  )\n\npoisson_simulation\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\nS4 class stanmodel 'poisson_simulation' coded as follows:\ndata {\n  int<lower=0> n_people;\n}\ngenerated quantities {\n  real<lower=0> avg_birds_per_person;\n  // an array -- like a list in R\n  array[n_people] int<lower=0> bird_count;\n\n  // simulate averages\n  avg_birds_per_person = uniform_rng(0, 60);\n  // simulate observations with that average\n  for (i in 1:n_people){\n    bird_count[i] = poisson_rng(avg_birds_per_person);\n  }\n} \n```\n\n\n:::\n:::\n\n\n\nWhat you see just above is not R, but is the first Stan program we will see in this course. \nStan code is written in a text file, which I've read in here just to display it for you.  \n\nWhen you sample the model, as we'll do later, Stan samples the posterior distribution using Hamiltonian Monte Carlo.\n\nBefore we run it, let's look at the parts of a Stan model:\n\n### Parts of a Stan model\n\nThis Stan program has two parts. Each part is separated with curly braces, `{}`. The are they `data` block and the `generated quantities` block:\n\n```Stan\ndata {\n  int<lower=0> n_people;\n}\n``` \n\nAnd the generated quantites block.\n\n```Stan\ngenerated quantities {\n  real<lower=0> avg_observed;\n  // an array -- like a list in R\n  array[n_people] int<lower=0> bird_count;\n  \n  // simulate averages\n  avg_birds_per_person = uniform_rng(0, 60);\n  // simulate observations with that average\n  for (i in 1:n_people){\n    bird_count[i] = poisson_rng(avg_birds_per_person);\n  }\n}\n``` \n \n:::{.callout-tip}\n### EXERCISE\nLet's look at similarities and differences to the procedure in R. Try to find a few similarities and differences between R code and Stan code!\n:::\n\n:::{.callout-note collapse=\"true\"}\nsimilarities: \n\n* We have a random number generating function for each of our distributions. \nIn R, these were called `runif` and `rpois`, here they are `uniform_rng` and `poisson_rng`.\n* Once again, the only thing we need to provide is `n_people`, the number of observers we have\n\ndifferences:\n\n* every line ends with a semicolon `;`\n* in Stan, the name of a variable is on the RIGHT of a line, while in R it's on the left.\n* we need to use a for-loop to generate random variables.\n* note the syntax for creating an `array` of integers. Arrays in Stan are a little like lists in R: they can hold any other kind of object, and are of a certain length. \n\n:::\n\n## Sampling in Stan\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We connect the data in R to the model in Stan using a \n# named list!\npoisson_simulation_datalist <- list(\n  n_people = 21\n)\n\npoisson_simulation_samp <- rstan::sampling(poisson_simulation,\n  data = poisson_simulation_datalist, \n  refresh = 0,\n  # usually not necessary -- this model has no parameters \n  algorithm = \"Fixed_param\")\n```\n:::\n\n\n\nThis generates a large number of simulated datasets -- the default is 4000 datasets! \nEach time the model samples, it draws a new value for the unobserved average (`avg_birds_per_person`) and for the number of birds seen by each person. \n\nLet's pull out just a few of these datasets and visualize them.\n\nWe'll use a wonderful package called [`tidybayes`](http://mjskay.github.io/tidybayes/) to easily extract posterior draws from `stanfit` objects. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidybayes)\npois_sim <- tidybayes::spread_draws(poisson_simulation_samp, \n                                    avg_birds_per_person,\n                                    bird_count[],\n                                    ndraws = 20,\n                                    seed = 525600)\n```\n:::\n\n\n\nHere we pass `tidybayes::spread_draws()` the model name, as well as the names of the parameters that we want to work with. The parameter `avg_birds_per_person` is a scalar, so we only need to mention it by name. The parameter vector `bird_count` needs square brackets after its name. This syntax is strange but gives us lots of options for more complex models, as we'll see! \n\nLet's see what we get from tidybayes by looking at the first few rows.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npois_sim |> \n  as.data.frame() |> \n  head(9) |> \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n| .chain| .iteration| .draw| avg_birds_per_person| bird_count|\n|------:|----------:|-----:|--------------------:|----------:|\n|      1|        553|   553|             16.80902|         17|\n|      1|        553|   553|             16.80902|         19|\n|      1|        553|   553|             16.80902|         18|\n|      1|        553|   553|             16.80902|         22|\n|      1|        553|   553|             16.80902|         21|\n|      1|        553|   553|             16.80902|         13|\n|      1|        553|   553|             16.80902|         14|\n|      1|        553|   553|             16.80902|         22|\n|      1|        553|   553|             16.80902|         18|\n\n\n:::\n:::\n\n\n\nRemember we asked for only 25 of the 4000 posterior samples. Here is one sample, and just a bit of the next. We can see that the value of `avg_birds_per_person` is the same within each iteration. The model uses this average to sample every `bird_count` value, one for each person making observations. Then the program takes a new value of `avg_birds_per_person` and simulates everyone's `bird_count` again!\n\nLet's take a look at some of these simulations:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npois_sim |> \n  ggplot(aes(x = bird_count)) + \n  geom_histogram(fill = \"orange\") + \n  geom_vline(aes(xintercept = avg_birds_per_person), col = \"darkgreen\", lwd = 1) + \n  facet_wrap(~.draw) + \n  theme_bw()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Prior simulations of bird counts. Green bars are the mean for a particular simulation, and orange histograms show the distribution of observations around this mean.](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n## Parameter recovery\n\nLet's go back and look at the fake datasets we created in R \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_birds_per_person\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 17.12789\n```\n\n\n:::\n\n```{.r .cell-code}\nbird_count\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 23 10 19 27 20 15 16 18 18 22 14 14 14 18 17 13 26 19 16 13 10\n```\n\n\n:::\n:::\n\n\n\nand let's see if we can recapture the only known parameter, `avg_birds_per_person`, which is equal to 17.127887.\n\nWe'll do it first in R, using the function `fitdistr` from the `MASS` package:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMASS::fitdistr(bird_count, dpois, start = list(lambda=10))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in stats::optim(x = c(23L, 10L, 19L, 27L, 20L, 15L, 16L, 18L, 18L, : one-dimensional optimization by Nelder-Mead is unreliable:\nuse \"Brent\" or optimize() directly\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     lambda  \n  17.2382812 \n ( 0.9060239)\n```\n\n\n:::\n:::\n\n\n\nThis could also be done with `glm`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbird_glm <- glm(bird_count ~ 1, family = \"poisson\")\nexp(coef(bird_glm))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept) \n    17.2381 \n```\n\n\n:::\n:::\n\n\n\nYou can see that in all cases we are getting close to the value of `avg_birds_per_person`, which in these simulations is the true value.\n\n### Sampling the posterior distribution in Stan\n\nTime for the [HMC Slides!](slides/03_Stan)\n\nWe will be doing a lot of Stan models this week, and we will begin by replicating the above GLM in Stan.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoisson_model <- rstan::stan_model(\n  file = \"topics/01_simulation/poisson_model.stan\",\n  model_name = \"poisson_model\")\n\npoisson_model\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\nS4 class stanmodel 'poisson_model' coded as follows:\ndata {\n  int<lower=0> n_people;\n  array[n_people] int<lower=0> bird_count_observed;\n}\nparameters {\n  real<lower=0> avg_birds_per_person;\n}\nmodel {\n  bird_count_observed ~ poisson(avg_birds_per_person);\n  avg_birds_per_person ~ uniform(0, 60);\n}\ngenerated quantities {\n  // an array -- like a list in R\n  array[n_people] int<lower=0> bird_count;\n\n  // simulate observations with that average\n  for (i in 1:n_people){\n    bird_count[i] = poisson_rng(avg_birds_per_person);\n  }\n} \n```\n\n\n:::\n:::\n\n\n\nThis model has all the same code as the previous one, but has two additional parts. \nLet's compare them\n\n:::{.column-screen}\n\n::::{.columns}\n\n::: {.column width=\"2.5%\"}\n:::\n\n::: {.column width=\"45%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code .code-overflow-wrap}\npoisson_simulation\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\nS4 class stanmodel 'poisson_simulation' coded as follows:\ndata {\n  int<lower=0> n_people;\n}\ngenerated quantities {\n  real<lower=0> avg_birds_per_person;\n  // an array -- like a list in R\n  array[n_people] int<lower=0> bird_count;\n\n  // simulate averages\n  avg_birds_per_person = uniform_rng(0, 60);\n  // simulate observations with that average\n  for (i in 1:n_people){\n    bird_count[i] = poisson_rng(avg_birds_per_person);\n  }\n} \n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"5%\"}\n:::\n\n::: {.column width=\"45%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code .code-overflow-wrap}\npoisson_model\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\nS4 class stanmodel 'poisson_model' coded as follows:\ndata {\n  int<lower=0> n_people;\n  array[n_people] int<lower=0> bird_count_observed;\n}\nparameters {\n  real<lower=0> avg_birds_per_person;\n}\nmodel {\n  bird_count_observed ~ poisson(avg_birds_per_person);\n  avg_birds_per_person ~ uniform(0, 60);\n}\ngenerated quantities {\n  // an array -- like a list in R\n  array[n_people] int<lower=0> bird_count;\n\n  // simulate observations with that average\n  for (i in 1:n_people){\n    bird_count[i] = poisson_rng(avg_birds_per_person);\n  }\n} \n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2.5%\"}\n:::\n\n::::\n\n:::\n\nWhat's different in this second Stan program? There are two new sections:\n\n* *parameters block*  : Indicated by `parameters {}`, this block includes all the unobserved quantities. In this case there is only one: `avg_birds_per_person`. We have to give this value a name and say what kind of number it is. Here is also the place to declare any constraints. In our example, we state that the parameter is always positive (because it is an average of counts).\n* *model block*  indicated by `model {}`, this block contains the model. What this means in a Bayesian model is that it lists the probability distribution for all the observations, and for all the unobserved parameters. In other words, it looks just like our mathematical expressions above. The model block can also contain intermediate calculations, for example combining data and parameters with an equation. We'll see examples later. \n\nThis Stan program also contains one line that's been moved. \n\n```Stan\n  avg_birds_per_person ~ uniform(0, 60);\n```\n\nhas been moved to the `model` block. This has two consequences. \n\nFirst, when the model sees our data, it's going to try to find values of `avg_birds_per_person` which make those data probable -- in other words, it is going to find the posterior distribution of possible values of the average. Together, the prior and the data constrain what those values can be.\n\nSecond, the `generated quantities` block means something different now. Previously, we had no idea what `avg_birds_per_person` should be, so we had the computer choose a random number from a wide range. We called this \"the prior\" Now, when the computer draws new values of `bird_count`, it is going to use the values from the posterior that it is finding in the `model {}` block . This means that the simulations, rather than being *prior* predictive checks, are now *posterior* predictive checks.\n\n\n## Parameter recovery\n\n:::{.callout-tip}\n### EXERCISE: parameter recovery in Stan\nUse the Stan code above to fit the model to our simulated data. Do we recover the parameters?\n:::\n\n:::{.callout-note collapse=\"true\"}\n### SOLUTION\nOnce again, we connect a dataset to our model with a list:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbird_data_list <- list(bird_count_observed = bird_count,\n                       n_people = length(bird_count))\n\npoisson_model_samp <- rstan::sampling(poisson_model, \n                                      data  = bird_data_list,\n                                      refresh = 0)\n\nsummary(poisson_model_samp)$summary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                          mean    se_mean        sd      2.5%       25%\navg_birds_per_person  17.29133 0.02261672 0.8816431  15.57717  16.69148\nbird_count[1]         17.29300 0.07687152 4.2517844   9.00000  14.00000\nbird_count[2]         17.33650 0.06715999 4.2114964  10.00000  14.00000\nbird_count[3]         17.39075 0.06702556 4.2348610  10.00000  14.00000\nbird_count[4]         17.25250 0.07114388 4.2449085   9.00000  14.00000\nbird_count[5]         17.36050 0.06971805 4.3035648   9.00000  14.00000\nbird_count[6]         17.25850 0.06832552 4.3164031  10.00000  14.00000\nbird_count[7]         17.33325 0.07065510 4.3133335   9.97500  14.00000\nbird_count[8]         17.26750 0.06733192 4.1986130  10.00000  14.00000\nbird_count[9]         17.24650 0.06760074 4.2252457  10.00000  14.00000\nbird_count[10]        17.31600 0.07210748 4.2432470   9.00000  14.00000\nbird_count[11]        17.25300 0.06658456 4.2534708  10.00000  14.00000\nbird_count[12]        17.26600 0.06920602 4.2779457  10.00000  14.00000\nbird_count[13]        17.29650 0.06801648 4.1935050  10.00000  14.00000\nbird_count[14]        17.39875 0.07151847 4.3008572  10.00000  14.00000\nbird_count[15]        17.28850 0.07701954 4.3527582   9.00000  14.00000\nbird_count[16]        17.33800 0.07159828 4.2882226  10.00000  14.00000\nbird_count[17]        17.35300 0.07049617 4.3282877  10.00000  14.00000\nbird_count[18]        17.26150 0.07121162 4.2332136   9.00000  14.00000\nbird_count[19]        17.21725 0.06854881 4.1986855  10.00000  14.00000\nbird_count[20]        17.40175 0.07273169 4.2889912  10.00000  14.00000\nbird_count[21]        17.27975 0.07080281 4.2271098  10.00000  14.00000\nlp__                 671.03420 0.01613589 0.6999904 669.03755 670.89259\n                           50%       75%     97.5%    n_eff      Rhat\navg_birds_per_person  17.28907  17.86921  19.05998 1519.590 1.0013517\nbird_count[1]         17.00000  20.00000  26.00000 3059.226 1.0001325\nbird_count[2]         17.00000  20.00000  26.00000 3932.345 0.9999590\nbird_count[3]         17.00000  20.00000  26.00000 3992.064 0.9995419\nbird_count[4]         17.00000  20.00000  26.00000 3560.095 1.0015001\nbird_count[5]         17.00000  20.00000  26.00000 3810.362 1.0001988\nbird_count[6]         17.00000  20.00000  26.00000 3990.967 0.9999574\nbird_count[7]         17.00000  20.00000  26.00000 3726.826 0.9999260\nbird_count[8]         17.00000  20.00000  26.00000 3888.389 0.9992242\nbird_count[9]         17.00000  20.00000  26.00000 3906.618 1.0006428\nbird_count[10]        17.00000  20.00000  26.00000 3462.868 0.9998367\nbird_count[11]        17.00000  20.00000  26.00000 4080.749 0.9996817\nbird_count[12]        17.00000  20.00000  26.00000 3821.050 0.9995255\nbird_count[13]        17.00000  20.00000  26.00000 3801.246 0.9997909\nbird_count[14]        17.00000  20.00000  26.00000 3616.376 0.9998891\nbird_count[15]        17.00000  20.00000  27.00000 3193.944 0.9995756\nbird_count[16]        17.00000  20.00000  26.00000 3587.149 0.9998720\nbird_count[17]        17.00000  20.00000  26.00000 3769.651 0.9997274\nbird_count[18]        17.00000  20.00000  26.00000 3533.773 0.9998664\nbird_count[19]        17.00000  20.00000  26.00000 3751.689 1.0003756\nbird_count[20]        17.00000  20.00000  26.00000 3477.466 1.0010472\nbird_count[21]        17.00000  20.00000  26.00000 3564.397 1.0007880\nlp__                 671.29515 671.46106 671.50609 1881.908 1.0005204\n```\n\n\n:::\n:::\n\n\n\n:::\n\nWe can look at a table of coefficients but it is much easier to once again look at posterior samples as a figure.\n\n:::{.callout-note}\n# Visualize everything! \nBayesian workflows are highly visual. Make as many plots as you can: of your parameters, your predictions, the performance of your chains, etc.\n:::\n\n### bayesplot\n\nAnother essential package for working with posterior samples is called [`bayesplot`](http://mc-stan.org/bayesplot/). Let's use it to look at the posterior distribution for `avg_birds_per_person`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbayesplot::mcmc_areas(poisson_model_samp, pars = \"avg_birds_per_person\") + \n  geom_vline(xintercept = avg_birds_per_person, col = \"orange\", lwd = 2)\n```\n\n::: {.cell-output-display}\n![posterior distribution for `avg_birds_per_person`. The orange line is the true parameter value, which we simulated in R.](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n#### Posterior predictive checks\n\nBayesian models MAKE data, which suggests a clear way to validate our models: ask the model to make some data, then see how well these data correspond to biology (e.g. to our real data).  Here, we will take 50 fake datasets of bird counts and compare them to the simulation we first did in R.\n\nThe process involves a bit of fiddling around in R to get the simulated data, but then `bayesplot` does all the work: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbird_count_draws <- rstan::extract(poisson_model_samp, pars = \"bird_count\")\nbayesplot::ppc_dens_overlay(y = bird_count,\n                            yrep = head(bird_count_draws$bird_count, 50))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n\n### tidybayes again\n\nAs we see above, `bayesplot` offers many out-of-the-box figures. Sometimes however, you'll want to control exactly what your figures look like, and for this `tidybayes` is an excellent tool. \n\nLet's use the flexibility of `tidybayes` to show how the prior and posterior differ between our two models\n\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\ntidybayes::gather_rvars(poisson_simulation_samp,\n                        avg_birds_per_person) |> \n  ggplot(aes(y = \"avg_birds_per_person\", dist = .value)) + \n  tidybayes::stat_halfeye() + \n  labs(title = \"Prior\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n\n```{.r .cell-code}\ntidybayes::gather_rvars(poisson_model_samp, \n                        avg_birds_per_person) |> \n  ggplot(aes(y = \"avg_birds_per_person\", dist = .value)) + \n  tidybayes::stat_halfeye() + \n  labs(title = \"Posterior\") + \n  coord_cartesian(xlim = c(0, 60))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-2.png){width=672}\n:::\n:::\n\n\n\n\n### Shinystan\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinystan::launch_shinystan(poisson_model_samp)\n```\n:::\n\n\n\n## Exercises\n\n#### Level 1\n\n* What would you do next to add complexity the bird-counting model above?\n* We plotted histograms to evaluate our model. Experiment with other types of plots. For example, what is the maximum value in each posterior simulation? What is the minimum? How to these compare to the real data? TIP: check out `?ppc_stat.`\n \n\n#### Level 2\n* Take a closer look at `poisson_model_samp$summary()`. All the values of `bird_count` are the same. That's correct, but why?\n* Try to fit YOUR data and your chosen distribution from [Monday's exercise](topics/00_distributions). Check to see if the distribution you chose is implemented in Stan -- see, for example, [this list](https://mc-stan.org/docs/functions-reference/binary_distributions.html). \n* check the fit using the plots we have already seen today.\n\n#### Level 3\n* You would never actually do the analysis in this exercise! If all you want is the average of a Poisson distribution, you can get that without any sampling at all. Start by writing the model with a different prior:\n\n$$\n\\begin{align}\n\\text{Number of Birds}_{\\text{seen by person i}} &\\sim \\text{Poisson}(\\lambda) \\\\\n\\lambda &\\sim \\text{Gamma}(9, .5)\n\\end{align}\n$$\n\nThis lets us calculate the posterior distribution directly. See the equation [on Wikipedia](https://en.wikipedia.org/wiki/Poisson_distribution#Bayesian_inference) and calculate the posterior for our bird data.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}