{
  "hash": "b93dccdfc969c3826be17b97786db0a9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Gaussian Processes in Stan\"\ndescription: |\n  Smooth lines in fancy colours.\nexecute:\n  freeze: true\ncomments:\n  hypothesis: true\nformat:\n  html:\n    code-tools: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n:::{.callout-tip}\n## Goals of this lesson\n1. Let's appreciate together the power of online community resources\n1. Gaussian Processes are families of smooth functions we learn from data\n1. When used for prediction, a GP is both a \"prior\" and a \"likelihood\"\n:::\n\n## Background reading\n\nGaussian processes are very common, and there are lots of resources on the topic:\n\n1. The Stan manual [has a chapter on it](https://mc-stan.org/docs/stan-users-guide/gaussian-processes.html)\n1. The Stan team gives lots of [example models on Github](https://github.com/stan-dev/example-models/blob/master/misc/gaussian-process/gp-fit-logit.stan) which I adapted for this example.\n1. Michael Betancourt has an extremely detailed, very rigous [tutorial on GPs](https://betanalpha.github.io/assets/case_studies/gaussian_processes.html#3_Inferring_A_Gaussian_Process)\n1. Here's a complete, worked [analysis of human birthdays](https://avehtari.github.io/casestudies/Birthdays/birthdays.html#Model_4:_long_term_smooth_+_seasonal_+_weekday_with_increasing_magnitude) by world-class statisticians (Gelman, Vehtari, Simpson, et al)\n1. GPs are related to GAMs and can be represented by a collection of basis functions. This is approximate but much much faster. See this [excellent tutorial](https://avehtari.github.io/casestudies/Motorcycle/motorcycle_gpcourse.html#45_GP_with_basis_functions_for_f_and_g) by Aki Vehtari, and the corresponding paper (citation in the blog post).\n1. this [blog](https://rpubs.com/NickClark47/stan_geostatistical) applies GPs to spatial count data\n1. Here is a very long and wonderfully detailed post describing a GP approach to [occupany modelling](https://peter-stewart.github.io/blog/gaussian-process-occupancy-tutorial/)\n1. Another [blog on Gaussian Processes](https://brendanhasz.github.io/2018/10/10/hmm-vs-gp.html#generating-data-from-a-gaussian-process), Hidden Markov Models and more, very clear explanation.\n\n<!-- add equation -->\n\n<!-- add simulation -->\n\n### Reorganizing the mite data\n\nLet's begin by (once again!) loading and reorganizing the mite data. This time we'll also use `mite.xy`, which gives the coordinates of each one of the 70 samples.\n\n#### Loading models and data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages(library(dplyr))\nlibrary(ggplot2)\nlibrary(tidyr)\n# library(cmdstanr)\nsuppressPackageStartupMessages(library(rstan))\nrstan_options(\"auto_write\" = TRUE)\noptions(mc.cores = parallel::detectCores())\nlibrary(tidybayes)\n\n# mite data\ndata(mite, package = \"vegan\")\ndata(mite.env, package = \"vegan\")\n\n## ALSO: the spatial data\ndata(mite.xy, package = \"vegan\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# combine data and environment\nmite_data_long <- bind_cols(mite.env, mite) |> \n  mutate(plot_id = 1:length(WatrCont)) |> \n  pivot_longer(Brachy:Trimalc2, names_to = \"spp\", values_to = \"abd\")\n\n\nmite_data_long_transformed <- mite_data_long |> \n  mutate(presabs = as.numeric(abd>0),\n         # center predictors\n         water = (WatrCont - mean(WatrCont)) / 100\n         )\n\n# pick a species that has about 50/50 chance \n\nmite_data_long_transformed |>\n  group_by(spp) |>\n  summarize(freq = mean(presabs)) |>\n  filter(freq > .4 & freq < .6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 2\n   spp       freq\n   <chr>    <dbl>\n 1 Ceratoz3 0.443\n 2 FSET     0.429\n 3 HMIN     0.486\n 4 MEGR     0.543\n 5 NCOR     0.5  \n 6 Oppiminu 0.429\n 7 Oribatl1 0.429\n 8 PWIL     0.486\n 9 TVEL     0.557\n10 Trhypch1 0.457\n```\n\n\n:::\n\n```{.r .cell-code}\n## how about: PWIL \n```\n:::\n\n\n\nLet's choose just one species as an example. \nI've chosen one where the relationship with water is rather strong, and for which presence and absence are roughly balanced. \nThis is just to make the example clear.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npwil_data <- mite_data_long_transformed |> \n  filter(spp == \"PWIL\")\n\npwil_data |> \n  ggplot(aes(x = water, y = presabs)) + geom_point() + \n  stat_smooth(method = glm, method.args = list(family = \"binomial\")) + \n  theme_minimal()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Probability of occurrance of one mite species, as a fuction of water content of the soil](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# add the spatial coordinates:\n\npwil_spatial <- bind_cols(pwil_data, mite.xy)\n\npwil_spatial |> \n  ggplot(aes(x = x, y = y, fill = as.factor(presabs))) + \n  geom_point(size = 3, pch = 21, stroke = 1) + \n  scale_fill_brewer(type = \"qual\", palette = \"Dark2\") + \n  theme_minimal() + \n  coord_fixed() + \n  labs(fill = \"Pres/Abs\")\n```\n\n::: {.cell-output-display}\n![Presence-absence data for mite species \"PWIL\", at the spatial location of each point.](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n\nWe'll look at two possibilities in turn:  \n\n1. A nonlinear function of one variable\n1. A smooth function of distance\n\n# Smooth function of one variable\n\n## Write the model\n\n\n$$\n\\begin{align}\n\\mathsf{Pr}(y_i = 1) &\\sim \\mathsf{Bernoulli}(p_i)\\\\\n\\mathsf{logit}(p_i) &= a + f_i\\\\ \nf_i &\\sim \\mathsf{multivariate\\ normal}(0, K(x | \\theta)) \\\\\n  K(x | \\alpha, \\rho, \\sigma)_{i, j}\n&= \\alpha^2\n\\exp \\left(\n- \\dfrac{1}{2 \\rho^2} \\sum_{d=1}^D (x_{i,d} - x_{j,d})^2\n\\right)\n+ \\delta_{i, j} \\sigma^2,\n\\end{align}\n$$\n\nThat's the general notation for D dimensions. In our case we're looking at something much simpler.\n\n$$\n\\begin{align}\n\\mathsf{Pr}(y_i = 1) &\\sim \\mathsf{Bernoulli}(p_i)\\\\\n\\mathsf{logit}(p_i) &= a + f_i\\\\ \nf_i &\\sim \\mathsf{Multivariate\\ Normal}(0, K(x | \\theta)) \\\\\n  K(x | \\alpha, \\rho, \\sigma)_{i, j}\n&= \\alpha^2\ne^{\n\\frac{-(\\text{water}_i - \\text{water}_j)^2}{2 \\rho^2}}\n+ \\delta_{i, j} \\sigma^2 \\\\\n\\rho &\\sim \\mathsf{Inverse\\ Gamma}(5, 14) \\\\\n\\alpha &\\sim \\mathsf{Normal}(0, .8) \\\\\na &\\sim \\mathsf{Normal}(0, .2) \\\\\n\\end{align}\n$$\n\nHere's an interpretation of the parameters of this model: \n\n* $a^2$ is the maximume covariance between two points\n* $\\rho$ tells us how quickly that covariance goes down as two samples become more different in their water amount\n* $\\delta_{i, j} \\sigma^2$ adds the variances along the diagonal\n\nSee the explanation of this function in the [Stan User's guide](https://mc-stan.org/docs/stan-users-guide/gaussian-processes.html#gaussian-process-regression)\n\n## Simulate to understand it\n\nHere is the Stan code that replicates the mathematical model above.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngp_example_sim <- stan_model(file = \"topics/04_gp/gp_example_sim.stan\")\n\ngp_example_sim\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\nS4 class stanmodel 'anon_model' coded as follows:\n// Fit the hyperparameters of a latent-variable Gaussian process with an\n// exponentiated quadratic kernel and a Bernoulli likelihood\n// This code is from https://github.com/stan-dev/example-models/blob/master/misc/gaussian-process/gp-fit-logit.stan\ndata {\n  int<lower=1> N;\n  array[N] real x;\n}\ntransformed data {\n  real delta = 1e-9;\n}\nparameters {\n  real<lower=0> rho;\n  real<lower=0> alpha;\n  real a;\n  vector[N] eta;\n  vector[N] y;\n}\ntransformed parameters {\n  vector[N] f;\n  {\n    matrix[N, N] L_K;\n    matrix[N, N] K = gp_exp_quad_cov(x, alpha, rho);\n\n    // diagonal elements\n    for (n in 1 : N) {\n      K[n, n] = K[n, n] + delta;\n    }\n\n    L_K = cholesky_decompose(K);\n    f = L_K * eta;\n  }\n}\nmodel {\n  rho ~ inv_gamma(5, 14);\n  alpha ~ normal(0, .8);\n  a ~ normal(0, .2);\n  eta ~ std_normal();\n} \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngp_example_sim_samples <- sampling(\n  gp_example_sim,\n  data = list(\n    N = 20,\n    x = seq(from = -3, to = 5, length.out = 20)),\n  refresh = 200, chains = 1\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nSAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1).\nChain 1: \nChain 1: Gradient evaluation took 2.7e-05 seconds\nChain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.27 seconds.\nChain 1: Adjust your expectations accordingly!\nChain 1: \nChain 1: \nChain 1: Iteration:    1 / 2000 [  0%]  (Warmup)\nChain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)\nChain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)\nChain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)\nChain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)\nChain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)\nChain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)\nChain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)\nChain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)\nChain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)\nChain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)\nChain 1: Iteration: 2000 / 2000 [100%]  (Sampling)\nChain 1: \nChain 1:  Elapsed Time: 10.013 seconds (Warm-up)\nChain 1:                12.298 seconds (Sampling)\nChain 1:                22.311 seconds (Total)\nChain 1: \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There were 23 divergent transitions after warmup. See\nhttps://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup\nto find out why this is a problem and how to eliminate them.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There were 898 transitions after warmup that exceeded the maximum treedepth. Increase max_treedepth above 10. See\nhttps://mc-stan.org/misc/warnings.html#maximum-treedepth-exceeded\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Examine the pairs() plot to diagnose sampling problems\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The largest R-hat is 2.12, indicating chains have not mixed.\nRunning the chains for more iterations may help. See\nhttps://mc-stan.org/misc/warnings.html#r-hat\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable.\nRunning the chains for more iterations may help. See\nhttps://mc-stan.org/misc/warnings.html#bulk-ess\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable.\nRunning the chains for more iterations may help. See\nhttps://mc-stan.org/misc/warnings.html#tail-ess\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx_value_df <- tibble::enframe(x = seq(from = -3, to = 5, length.out = 20),\n                      name = \"i\", value = \"water\")\n\ngp_example_sim_samples |> \n  tidybayes::spread_draws(f[i], a, ndraws = 45) |> \n  left_join(x_value_df) |> \n  ggplot(aes(x = water, y = plogis(f + a), group = .draw)) + \n  geom_line() + \n  coord_cartesian(ylim = c(0, 1))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(i)`\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n\n## Express that model in code\n\nWith a working simulation, we can now adapt the model to handle real data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngp_example_pred <- stan_model(\n  file = \"topics/04_gp/gp_example_pred.stan\")\n\ngp_example_pred\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\nS4 class stanmodel 'anon_model' coded as follows:\n// Fit the hyperparameters of a latent-variable Gaussian process with an\n// exponentiated quadratic kernel and a Bernoulli likelihood\n// This code is from https://github.com/stan-dev/example-models/blob/master/misc/gaussian-process/gp-fit-logit.stan\ndata {\n  int<lower=1> Nobs;\n  int<lower=1> N;\n  array[N] real x;\n  array[Nobs] int<lower=0, upper=1> z;\n}\ntransformed data {\n  real delta = 1e-9;\n}\nparameters {\n  real<lower=0> rho;\n  real<lower=0> alpha;\n  real a;\n  vector[N] eta;\n}\ntransformed parameters {\n  vector[N] f;\n  {\n    matrix[N, N] L_K;\n    matrix[N, N] K = gp_exp_quad_cov(x, alpha, rho);\n\n    // diagonal elements\n    for (n in 1 : N) {\n      K[n, n] = K[n, n] + delta;\n    }\n\n    L_K = cholesky_decompose(K);\n    f = L_K * eta;\n  }\n}\nmodel {\n  rho ~ inv_gamma(5, 14);\n  alpha ~ normal(0, .8);\n  a ~ normal(0, .2);\n  eta ~ std_normal();\n\n  z ~ bernoulli_logit(a + f[1:Nobs]);\n} \n```\n\n\n:::\n:::\n\n\n\nWe need to generate data for making predictions! I'll create a new vector of observations called `new_x` that cover the range of the `water` variable in our dataset.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sample N values on the range of x\nnew_x <- seq(from = -3, to = 5, length.out = 15)\n\ngp_data_list <- list(N = length(pwil_spatial$presabs) + length(new_x),\n                     Nobs = length(pwil_spatial$presabs),\n                     x = c(pwil_spatial$water, new_x),\n                     z = pwil_spatial$presabs)\n\n# put them on the dataframe\ngp_example_pwil_samp <- sampling(\n  gp_example_pred,\n  data = gp_data_list,\n  chains = 2, refresh = 1000)\n\n# gp_example_samp$save_object(\"topics/04_gp/gp_example_samp_pwil.rds\")\n```\n:::\n\n\n\n:::{.callout-tip}\nNote that `cmdstanr` models have a method called `$save_object()`, which lets you save the model outputs into an `.rds` object.\n\nAlso note that these notes have been converted to `rstan` so this tip doesn't help that much anymore ;) \n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# gp_example_samp_pwil <- read_rds(\n#   \"topics/04_gp/gp_example_samp_pwil.rds\")\n\nwater_prediction_points <- gp_example_pwil_samp |> \n  tidybayes::gather_rvars(f[rownum]) |> \n  slice(-(1:length(pwil_spatial$presabs)))\n\nwater_prediction_points |> \n  mutate(water = new_x,\n         presabs = posterior::rfun(plogis)(.value)) |> \n  ggplot(aes(x = water, dist = presabs)) + \n  tidybayes::stat_lineribbon() + \n  # scale_fill_viridis_d(option = \"rocket\") + \n  scale_fill_brewer(palette = \"Reds\", direction  = -1) + \n  geom_jitter(aes(x = water, y = presabs), \n              inherit.aes = FALSE, \n              height = .01, width = 0,\n              data = pwil_spatial)\n```\n\n::: {.cell-output-display}\n![A Gaussian Process estimates a distribution of smooth functions to a dataset. Here we're using it to estimate the effect of water amount on the occurence of a mite.](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n<!-- ![](topics/04_gp/pwil_water.png) -->\n\nWe can also pull out some specific functions. What I want you to see here is that there are MANY curvy lines that are consistent with this model.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsome_predicted_lines <-  gp_example_pwil_samp |> \n  # take just some draws\n  tidybayes::spread_draws(a, f[rownum], ndraws = 63) |> \n  # remove the rows that match observed data,\n  # and look only at the points for predictions.\n  filter(rownum > length(pwil_spatial$presabs)) |> \n  # convert to probability\n  mutate(prob = plogis(f + a),\n         rownum = rownum - 70) |> \n  ## need a dataframe that says which \"rownum\" from \n  ## above goes with which value of water from the\n  ## new_x vector I made:\n  left_join(tibble::enframe(new_x,\n                            name = \"rownum\", \n                            value = \"water\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(rownum)`\n```\n\n\n:::\n\n```{.r .cell-code}\nsome_predicted_lines |> \n  ggplot(aes(x = water, y = prob, group = .draw)) + \n  geom_line(alpha = 0.7) + \n  theme_minimal() + \n  coord_cartesian(ylim = c(0, 1))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\n# Spatial predictions\n\nTo make a prediction of a function on one X variable, we needed a sequence of points to predict along. \n\nTo make spatial predictions, we need a _grid_ of points to predict along.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid_points <- modelr::data_grid(mite.xy, \n                                 x = modelr::seq_range(x, by = .5),\n                                 y = modelr::seq_range(y, by = .5)) \n\ngrid_points |> \n  ggplot(aes(x = x, y = y)) + \n  geom_point() + \n  coord_fixed()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\nOther than a change in the `data {}` block, the Stan code is unchanged! \n\n\n### Prior predictive simulations\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngp_example_2D_prior <- stan_model(\n  file = \"topics/04_gp/gp_example_2D_prior.stan\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in readLines(file, warn = TRUE): incomplete final line found on\n'/home/andrew/Documents/Projects/hiermod/topics/04_gp/gp_example_2D_prior.stan'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrecompiling to avoid crashing R session\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTrying to compile a simple C file\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\nRunning /usr/lib/R/bin/R CMD SHLIB foo.c\nusing C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’\ngcc -I\"/usr/share/R/include\" -DNDEBUG   -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/Rcpp/include/\"  -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/RcppEigen/include/\"  -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/RcppEigen/include/unsupported\"  -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/BH/include\" -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/include/src/\"  -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/include/\"  -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/RcppParallel/include/\"  -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/rstan/include\" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1       -fpic  -g -O2 -ffile-prefix-map=/build/r-base-JpkSDg/r-base-4.4.3=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2  -c foo.c -o foo.o\nIn file included from /home/andrew/R/x86_64-pc-linux-gnu-library/4.4/RcppEigen/include/Eigen/Core:19,\n                 from /home/andrew/R/x86_64-pc-linux-gnu-library/4.4/RcppEigen/include/Eigen/Dense:1,\n                 from /home/andrew/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/include/stan/math/prim/fun/Eigen.hpp:22,\n                 from <command-line>:\n/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/RcppEigen/include/Eigen/src/Core/util/Macros.h:679:10: fatal error: cmath: No such file or directory\n  679 | #include <cmath>\n      |          ^~~~~~~\ncompilation terminated.\nmake: *** [/usr/lib/R/etc/Makeconf:195: foo.o] Error 1\n```\n\n\n:::\n\n```{.r .cell-code}\ngp_example_2D_prior\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\nS4 class stanmodel 'anon_model' coded as follows:\n// Fit the hyperparameters of a latent-variable Gaussian process with an\n// exponentiated quadratic kernel and a Bernoulli likelihood\n// This code is from https://github.com/stan-dev/example-models/blob/master/misc/gaussian-process/gp-fit-logit.stan\ndata {\n  // int<lower=1> Nobs;\n  int<lower=1> N;\n  array[N] vector[2] x;\n  real rho_a;\n  real rho_b;\n  // array[Nobs] int<lower=0, upper=1> z;\n}\ntransformed data {\n  real delta = 1e-9;\n}\nparameters {\n  real<lower=0> rho;\n  real<lower=0> alpha;\n  real a;\n  vector[N] eta;\n}\ntransformed parameters {\n  vector[N] f;\n  {\n    matrix[N, N] L_K;\n    matrix[N, N] K = gp_exp_quad_cov(x, alpha, rho);\n\n    // diagonal elements\n    for (n in 1 : N) {\n      K[n, n] = K[n, n] + delta;\n    }\n\n    L_K = cholesky_decompose(K);\n    f = L_K * eta;\n  }\n}\nmodel {\n  rho ~ inv_gamma(rho_a, rho_b);\n  alpha ~ normal(0, .8);\n  a ~ normal(0, .2);\n  eta ~ std_normal();\n  // z ~ bernoulli_logit(a + f[1:Nobs]);\n} \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngp_example_2D_prior_samp <- sampling(\n  gp_example_2D_prior,\n  data = list(N = nrow(grid_points),\n              x = grid_points,\n              rho_a = 5, rho_b = 14),\n  chains = 2, refresh = 1000)\n```\n:::\n\n\n\n### visualize the prior\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  ## extract the predictors\ngp_example_2D_prior_samp |> \n  tidybayes::spread_draws(f[rownum], a, ndraws = 6) |> \n  mutate(rownum = as.character(rownum)) |> \n  left_join(grid_points |> \n  tibble::rownames_to_column(\"rownum\"), by = join_by(rownum)) |> \n  mutate(presabs = plogis(f + a)) |> \n  ggplot(aes(x = x, y = y, fill = presabs)) + \n  geom_tile()+\n  scale_fill_viridis_c(option = \"rocket\") + \n  coord_fixed()+\n  theme_minimal() + \n  labs(fill = \"Pr(y=1)\") + \n  facet_wrap(~.draw) +\n  NULL \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n\n:::{.callout-warning}\n## CAUTION: Slow\nThe model below, over 70 points, is the slowest model we've seen so far and takes about 1 minute on my (Andrew's) laptop.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngp_example_pred_2D <- stan_model(\n  file = \"topics/04_gp/gp_example_pred_2D.stan\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in readLines(file, warn = TRUE): incomplete final line found on\n'/home/andrew/Documents/Projects/hiermod/topics/04_gp/gp_example_pred_2D.stan'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrecompiling to avoid crashing R session\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTrying to compile a simple C file\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\nRunning /usr/lib/R/bin/R CMD SHLIB foo.c\nusing C compiler: ‘gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0’\ngcc -I\"/usr/share/R/include\" -DNDEBUG   -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/Rcpp/include/\"  -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/RcppEigen/include/\"  -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/RcppEigen/include/unsupported\"  -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/BH/include\" -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/include/src/\"  -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/include/\"  -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/RcppParallel/include/\"  -I\"/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/rstan/include\" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1       -fpic  -g -O2 -ffile-prefix-map=/build/r-base-JpkSDg/r-base-4.4.3=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2  -c foo.c -o foo.o\nIn file included from /home/andrew/R/x86_64-pc-linux-gnu-library/4.4/RcppEigen/include/Eigen/Core:19,\n                 from /home/andrew/R/x86_64-pc-linux-gnu-library/4.4/RcppEigen/include/Eigen/Dense:1,\n                 from /home/andrew/R/x86_64-pc-linux-gnu-library/4.4/StanHeaders/include/stan/math/prim/fun/Eigen.hpp:22,\n                 from <command-line>:\n/home/andrew/R/x86_64-pc-linux-gnu-library/4.4/RcppEigen/include/Eigen/src/Core/util/Macros.h:679:10: fatal error: cmath: No such file or directory\n  679 | #include <cmath>\n      |          ^~~~~~~\ncompilation terminated.\nmake: *** [/usr/lib/R/etc/Makeconf:195: foo.o] Error 1\n```\n\n\n:::\n\n```{.r .cell-code}\ngp_example_pred_2D\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` stan\nS4 class stanmodel 'anon_model' coded as follows:\n// Fit the hyperparameters of a latent-variable Gaussian process with an\n// exponentiated quadratic kernel and a Bernoulli likelihood\n// This code is from https://github.com/stan-dev/example-models/blob/master/misc/gaussian-process/gp-fit-logit.stan\ndata {\n  int<lower=1> Nobs;\n  int<lower=1> N;\n  array[N] vector[2] x;\n  array[Nobs] int<lower=0, upper=1> z;\n}\ntransformed data {\n  real delta = 1e-9;\n}\nparameters {\n  real<lower=0> rho;\n  real<lower=0> alpha;\n  real a;\n  vector[N] eta;\n}\ntransformed parameters {\n  vector[N] f;\n  {\n    matrix[N, N] L_K;\n    matrix[N, N] K = gp_exp_quad_cov(x, alpha, rho);\n\n    // diagonal elements\n    for (n in 1 : N) {\n      K[n, n] = K[n, n] + delta;\n    }\n\n    L_K = cholesky_decompose(K);\n    f = L_K * eta;\n  }\n}\nmodel {\n  rho ~ inv_gamma(5, 14);\n  alpha ~ normal(0, .8);\n  a ~ normal(0, .2);\n  eta ~ std_normal();\n\n  z ~ bernoulli_logit(a + f[1:Nobs]);\n} \n```\n\n\n:::\n:::\n\n\n\nplot the effect in space:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## sample the model\ngp_example_2D_samp <- sampling(\n  gp_example_pred_2D,\n  data = list(N = length(pwil_spatial$presabs) + nrow(grid_points),\n              Nobs = length(pwil_spatial$presabs),\n              x = bind_rows(pwil_spatial[c(\"x\", \"y\")], grid_points),\n              z = pwil_spatial$presabs),\n  chains = 2, refresh = 200)\n\n\n# gp_example_2D_samp$save_object(\"topics/04_gp/gp_example_2D_samp_pwil.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# gp_example_2D_samp_pwil <- read_rds(\"topics/04_gp/gp_example_2D_samp_pwil.rds\")\n\n## extract the predictors\ngp_example_2D_samp |> \n  tidybayes::spread_rvars(f[rownum], a) |> \n  slice(-(1:length(pwil_spatial$presabs))) |> \n  bind_cols(grid_points) |> \n  mutate(presabs = posterior::rfun(plogis)(f + a),\n         pa_median = median(presabs)) |> \n  ggplot(aes(x = x, y = y, fill = pa_median)) + \n  geom_tile()+\n  geom_point(aes(x = x,\n                 y = y,\n                 fill = presabs),\n             inherit.aes = FALSE,\n             data = pwil_spatial,\n             pch = 21 ,\n             size = 2.5,\n             stroke = .3,\n             colour = \"lightblue\"\n             ) + \n  scale_fill_viridis_c(option = \"rocket\") + \n  coord_fixed()+\n  theme_minimal() + \n  labs(fill = \"Pr(y=1)\") + \n  NULL \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# ggsave(\"topics/04_gp/pwil_spatial.png\")\n```\n:::\n\n\n\n<!-- ![](topics/04_gp/pwil_spatial.png) -->\n\n## Extensions:\n\nAdd water to the model. Does the spatial effect disappear, increase, or stay kind of the same?\n\nNext step: try to model water curve for more than one species. Would it be possible to make the species rho parameters hierarchical?\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}